<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[拓扑排序及应用]]></title>
      <url>/2017/10/25/topo-sort/</url>
      <content type="html"><![CDATA[<!-- more -->
<h2 id="什么是拓扑排序">什么是拓扑排序:</h2>

<p>对于一个有向图G, 如果存在一种结点的序列, 使得对于每条边(u, v), 都有u在v的前面, 则这个顺序叫做拓扑序, 给图排拓扑序的过程即是拓扑排序</p>

<p><strong>显然, 只有DAG才存在拓扑序。</strong></p>

<h2 id="如何进行拓扑排序">如何进行拓扑排序:</h2>

<p>有两种方法:</p>

<p><strong>1.dfs:</strong></p>

<p>dfs遍历DAG, 并在遍历完后将结点放在当前序列的首部</p>

<p><strong>—-代码—-(来自紫书)</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">topo</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span> <span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">dfs</span>
<span class="p">{</span>
	<span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">//访问标志
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//存在有向环, 排序失败
</span>			<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">topo</span><span class="p">[</span><span class="o">--</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">u</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>2.bfs:</strong></p>

<p>运用一个队列, 删除在队头的结点， 并寻找入度为0的点入队</p>

<p><strong>—-代码—-</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">topo</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">in</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span> <span class="c1">//入度
</span><span class="kt">int</span> <span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">h</span><span class="o">!=</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">e</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">topo</span><span class="p">[</span><span class="n">h</span><span class="p">]]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="o">--</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">])</span>
			<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">++</span><span class="n">h</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="拓扑排序的作用">拓扑排序的作用:</h2>

<p>首先, 拓扑序可以用来定任务的起始时间, 这也是一般书上讲的东西</p>

<p>其次, 拓扑序<strong>可以判定一个有向图是不是DAG</strong></p>

<p>因为<strong>有且只有DAG才存在拓扑序</strong></p>

<p>那么, 如果将DAG的性质和定序结合起来会怎么样?</p>

<p>我们知道, <strong>DAG与dp有密不可分的关系</strong></p>

<p>而拓扑序可以给出DAG的处理顺序…</p>

<p>也就是说, <strong>拓扑序可以给出DAG上dp的计算顺序</strong></p>

<p>这也是一般DAG上dp的优化思路</p>
]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 图论 </tag>
        
          <tag> 拓扑排序 </tag>
        
          <tag> DAG </tag>
        
          <tag> dp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[tarjan求scc及其应用]]></title>
      <url>/note/%E5%9B%BE%E8%AE%BA/tarjan/2017/10/25/tarjan/</url>
      <content type="html"><![CDATA[<!-- more -->
<h2 id="什么是scc强连通分量">什么是scc(强连通分量):</h2>

<p>在有向图中, 如果若干个点相互可达, 则这几个点构成的集合称为有向图的一个强连通分量</p>

<p>如果把这个图中所有的极大强连通分量变为一个点, 这个图叫scc图。这个图中不存在有向环, 所以scc图是一个DAG</p>

<h2 id="如何求有向图的scc">如何求有向图的scc:</h2>

<p>一般使用tarjan算法</p>

<p>tarjan借助<strong>dfs</strong>, 在dfs时记录访问的结点v的<strong>时间戳</strong>(pre), 并设<strong>v及其后代在dfs树上能追溯到的最早的祖先结点</strong>为low, 当回溯时如果pre==low, 则说明找到一个scc。</p>

<p>用一个栈辅助存储dfs中子树的结点, 当找到scc时将栈中的结点弹出, 弹出的结点即是scc中的结点。</p>

<p><strong>—-代码—-</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//时间戳
</span><span class="kt">int</span> <span class="n">pre</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span> <span class="n">scc</span><span class="p">[</span><span class="n">Mn</span><span class="p">]</span> <span class="c1">//pre,low,结点的scc编号
</span><span class="kt">int</span> <span class="n">scn</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//scc计数器
</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">S</span><span class="p">;</span> <span class="c1">//辅助存储
</span><span class="kt">void</span> <span class="nf">tarjan</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pre</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">t</span><span class="p">;</span>
	<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">S</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>	<span class="c1">//遍历有向边
</span>	<span class="p">{</span>
		<span class="kt">int</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="c1">//如果未访问, 即访问到的是子结点
</span>		<span class="p">{</span>
			<span class="n">tarjan</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">//dfs
</span>			<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">scc</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="c1">//如果访问到的是祖先节点
</span>			<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">pre</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="o">++</span><span class="n">scn</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">u</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="p">());</span> <span class="n">S</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">scc</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">scn</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">==</span><span class="n">x</span><span class="p">)</span>	<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="scc的作用">scc的作用:</h2>
]]></content>
      <categories>
        
          <category> note </category>
        
          <category> 图论 </category>
        
          <category> tarjan </category>
        
      </categories>
      <tags>
        
          <tag> 图论 </tag>
        
          <tag> 缩点 </tag>
        
          <tag> tarjan </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈dp与DAG的关系]]></title>
      <url>/note/dp/%E5%9B%BE%E8%AE%BA/2017/10/25/DAGviaDP/</url>
      <content type="html"><![CDATA[<!-- more -->
<p>最近做了好几道跟DAG有关的题, 发现许多都和dp有关, 经过一番思考, 想到一些东西, 在这里记录下来。</p>

<p>首先是dp的定义: <strong>通过定义状态和状态间的关系, 拆分子问题去求解最优解。</strong></p>

<p>拆分子问题实质上是一个递归的过程, 类似于分治</p>

<p>如果把状态和状态间的转移关系看成一张有向图G的话, 那么拆分问题的过程 <strong>实质上是在G上进行dfs</strong></p>

<p>如果G不是DAG的话, 那么G中就会有一个环(就像下面这个图)</p>

<p><img src="/assets/images/pic_cir_gra.png" alt="Circle" /></p>

<p>在G中进行dfs时, 假如从1开始dfs, 那么遍历到3时,  3的最优解要由1决定, 而1的最优解还未求得, 导致答案错误。</p>

<p>所以根据状态和状态转移关系定义的图一定要是一个DAG, 否则无法通过dp求解</p>
]]></content>
      <categories>
        
          <category> note </category>
        
          <category> dp </category>
        
          <category> 图论 </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> DAG </tag>
        
          <tag> 图论 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1137) 旅行计划]]></title>
      <url>/solution/dp/%E5%9B%BE%E8%AE%BA/2017/10/24/trip_plan/</url>
      <content type="html"><![CDATA[<!-- more -->
<h2 id="题目描述">题目描述：</h2>

<p><strong>小明要去一个国家旅游。这个国家有N个城市，编号为1～N，并且有M条道路连接着，小明准备从其中一个城市出发，并只往东走到城市i停止。</strong></p>

<p><strong>所以他就需要选择最先到达的城市，并制定一条路线以城市i为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。</strong></p>

<p><strong>现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的i，都需要你为小明制定一条路线，并求出以城市i为终点最多能够游览多少个城市。</strong></p>

<h2 id="输入输出">输入输出：</h2>

<h3 id="输入">输入：</h3>

<p><strong>输入的第1行为两个正整数N, M。</strong></p>

<p><strong>接下来M行，每行两个正整数x, y，表示了有一条连接城市x与城市y的道路，保证了城市x在城市y西面。</strong></p>

<h3 id="输出">输出：</h3>

<p><strong>输出包括N行，第i行包含一个正整数，表示以第i个城市为终点最多能游览多少个城市。</strong></p>

<h2 id="题解">题解：</h2>

<p>由于只往东走，所以这是一个 <strong>DAG</strong></p>

<p>DAG上的最长路用dp解决</p>

<p>求拓扑序时dp求解最长路</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">100005</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">200005</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">edge</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">edge</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="o">*</span><span class="n">vr</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">Er</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span>	<span class="c1">//反向边
</span><span class="n">edge</span> <span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">E</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">ans</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">topo</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>	<span class="c1">//拓扑序
</span><span class="kt">int</span> <span class="n">in</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>	<span class="c1">//入度
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
		<span class="o">++</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="p">];</span>
		<span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
		<span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">E</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
		<span class="n">Er</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">Er</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="o">=</span><span class="n">vr</span><span class="p">[</span><span class="n">e</span><span class="p">];</span>
		<span class="n">vr</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">Er</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*求拓扑序*/</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">h</span><span class="o">!=</span><span class="n">t</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">e</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">topo</span><span class="p">[</span><span class="n">h</span><span class="p">]]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="o">--</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
				<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">er</span><span class="p">(</span><span class="n">vr</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]);</span><span class="n">er</span><span class="p">;</span><span class="n">er</span><span class="o">=</span><span class="n">er</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
					<span class="n">ans</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">],</span><span class="n">ans</span><span class="p">[</span><span class="n">er</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>	<span class="c1">//状态转移方程
</span>			<span class="p">}</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">h</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*--------*/</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
          <category> 图论 </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> 图论 </tag>
        
          <tag> DAG </tag>
        
          <tag> 拓扑排序 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1908)逆序对]]></title>
      <url>/solution/%E5%88%86%E6%B2%BB/2017/10/24/rev/</url>
      <content type="html"><![CDATA[<p>一道经典题
<!-- more --></p>

<h2 id="思路">思路:</h2>

<p><strong>使用归并排序的思想解决</strong></p>

<p>将序列从小到大归并排序</p>

<p>当右边的值小于左边的值时加上左边未归并的长度</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">40005</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">mg</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">m</span><span class="p">((</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">mg</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">);</span> <span class="n">ret</span> <span class="o">+=</span> <span class="n">mg</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">li</span><span class="p">(</span><span class="n">l</span><span class="p">),</span><span class="n">ri</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">j</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="k">while</span><span class="p">(</span><span class="n">li</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">&amp;&amp;</span><span class="n">ri</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">li</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">a</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span>	<span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">li</span><span class="o">++</span><span class="p">];</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ri</span><span class="o">++</span><span class="p">];</span>
				<span class="n">ret</span> <span class="o">+=</span> <span class="n">m</span><span class="o">-</span><span class="n">li</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span><span class="p">(;</span><span class="n">li</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">li</span><span class="p">)</span>	<span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">li</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(;</span><span class="n">ri</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="o">++</span><span class="n">ri</span><span class="p">)</span>	<span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ri</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="n">l</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> 分治 </category>
        
      </categories>
      <tags>
        
          <tag> 分治 </tag>
        
          <tag> 归并排序 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1010)幂次方]]></title>
      <url>/%E5%88%86%E6%B2%BB/%E9%80%92%E5%BD%92/2017/10/24/pow/</url>
      <content type="html"><![CDATA[<!-- more -->

<p>将一个数拆分成二进制, 对次数递归表示, 特殊处理0和2的情况</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">pow2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>    <span class="c1">//特殊处理0
</span>	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">)</span>    <span class="c1">//二进制拆分
</span>			<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">//特殊处理2
</span>				<span class="k">else</span>
				<span class="p">{</span>
					<span class="n">printf</span><span class="p">(</span><span class="s">"2("</span><span class="p">);</span>
					<span class="n">pow2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
					<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">')'</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">n</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'+'</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">pow2</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> 分治 </category>
        
          <category> 递归 </category>
        
      </categories>
      <tags>
        
          <tag> 分治 </tag>
        
          <tag> 二进制 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1216)数字三角形(USACO1.5)]]></title>
      <url>/solution/dp/2017/10/24/numtri/</url>
      <content type="html"><![CDATA[<p><strong>Blog第一篇</strong></p>

<p>一道经典题。</p>

<!-- more -->

<p>两个方法:</p>
<h2 id="自底向上推出最优解">自底向上推出最优解:</h2>

<p>用dp[i][j]表示从(i,j)开始的最优解, 答案即为dp[1][1]</p>

<p>状态转移方程: <strong>dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + map[i][j]</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MR</span><span class="p">(</span><span class="mi">1001</span><span class="p">);</span>    <span class="c1">//n(即题目中的r)的最大值
</span><span class="kt">int</span> <span class="n">map</span><span class="p">[</span><span class="n">MR</span><span class="p">][</span><span class="n">MR</span><span class="p">];</span>    <span class="c1">//保存输入数据
</span><span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">MR</span><span class="p">][</span><span class="n">MR</span><span class="p">];</span>    <span class="c1">//最优解
</span><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dmax</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>    <span class="c1">//返回最大值
</span><span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">//输入n
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>    <span class="c1">//输入数据
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>    <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>   <span class="c1">//初始化，最后一行数据的最优值即为其本身
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dmax</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>    <span class="c1">//向上递推求出最优解
</span>        <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>    <span class="c1">//输出最优解
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="自顶而下推出最优解">自顶而下推出最优解:</h2>
<p>用dp[i][j]表示以(i,j)结束的最优解, 则最优解为最后一行中dp的最大值</p>

<p>状态转移方程: <strong>dp[i][j] = max(dp[i-1][j-1],dp[i-1][j]) + map[i][j]</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">1002</span><span class="p">);</span>    <span class="c1">//n的最大值(定义成1002是为了便于处理边界)
</span><span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mn</span><span class="p">];</span>    <span class="c1">//最优解
</span><span class="cm">/*边读边求所以省去了map数组*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">//输入n
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tn</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tn</span><span class="p">;</span>    <span class="c1">//输入数据
</span>            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">tn</span><span class="p">;</span>    <span class="c1">//求解最优解
</span>        <span class="p">}</span>
    <span class="kt">int</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="n">max</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>    <span class="c1">//寻找最优解
</span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">;</span>    <span class="c1">//输出最优解
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>

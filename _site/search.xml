<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[二分查找]]></title>
      <url>/note/%E5%88%86%E6%B2%BB/2017/11/04/binsear/</url>
      <content type="html"><![CDATA[<!-- more -->
<h2 id="什么是二分查找">什么是二分查找:</h2>

<p>二分查找是一个基础算法. 其过程就是将需要查找的值与中间值进行比较, <strong>每次都将查找的区间缩小一半</strong>, 最后得到答案. 时间复杂度为O(logn)</p>

<p>下面是最基本的二分查找代码</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">key</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">((</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span><span class="o">==</span><span class="n">key</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span><span class="o">&lt;</span><span class="n">key</span><span class="p">)</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="二分查找的变种">二分查找的变种:</h2>

<p>做题的时候经常能碰到这样的情况: 寻找某个最大值或最小值. 这个时候也能使用二分查找, 不过边界处理要困难一些.</p>

]]></content>
      <categories>
        
          <category> note </category>
        
          <category> 分治 </category>
        
      </categories>
      <tags>
        
          <tag> 分治 </tag>
        
          <tag> 二分答案 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1462)通往奥格瑞玛的道路]]></title>
      <url>/solution/%E6%9C%80%E7%9F%AD%E8%B7%AF/%E5%88%86%E6%B2%BB/2017/11/03/road/</url>
      <content type="html"><![CDATA[<!-- more -->
<h2 id="题目描述">题目描述:</h2>

<p><strong>从结点1出发, 到结点n(n&lt;=10000), 一共有m(m&lt;=50000)条双向的道路, 给出每个点的权值, 以及初始血量, 求最大权值的最小值(无解输出”AFK”)</strong></p>

<h2 id="思路">思路;</h2>

<p><strong>最短路+二分答案</strong></p>

<p>求解极值考虑使用二分答案</p>

<p>对权值进行二分搜索, 用dijkstra求最少血量损失, 求最短路时去掉比权值大的点.</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">10005</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">100005</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">edge</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">e</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">E</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span> <span class="c1">//边表
</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">hp</span><span class="p">;</span> <span class="c1">//结点数及血量上限
</span><span class="kt">int</span> <span class="n">v</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">dc</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">isd</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="n">d</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">node</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">d</span><span class="o">&gt;</span><span class="n">x</span><span class="p">.</span><span class="n">d</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="kt">bool</span> <span class="nf">dij</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="c1">//堆优化dijkstra
</span><span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span><span class="mh">0x3f</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">dc</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">isd</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">isd</span><span class="p">);</span>
	<span class="n">dc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>
	<span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">node</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span><span class="n">dc</span><span class="p">[</span><span class="mi">1</span><span class="p">]});</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">np</span><span class="p">(</span><span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">u</span><span class="p">);</span>
		<span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">isd</span><span class="p">[</span><span class="n">np</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">==</span><span class="n">n</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">dc</span><span class="p">[</span><span class="n">np</span><span class="p">]</span><span class="o">&lt;</span><span class="n">hp</span><span class="p">)</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">else</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//如果最小损失血量大于血量上限, 答案不可行
</span>			<span class="p">}</span>
			<span class="n">isd</span><span class="p">[</span><span class="n">np</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">e</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="p">]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">next</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">e</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">d</span> <span class="o">&amp;&amp;</span> <span class="n">dc</span><span class="p">[</span><span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">e</span><span class="p">]</span><span class="o">&gt;</span><span class="n">dc</span><span class="p">[</span><span class="n">np</span><span class="p">]</span><span class="o">+</span><span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">c</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">dc</span><span class="p">[</span><span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">dc</span><span class="p">[</span><span class="n">np</span><span class="p">]</span><span class="o">+</span><span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">c</span><span class="p">;</span>
					<span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">node</span><span class="p">){</span><span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">e</span><span class="p">,</span><span class="n">dc</span><span class="p">[</span><span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">e</span><span class="p">]});</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">hp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mf</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//所有结点的最大权值
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">f</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
		<span class="n">mf</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
		<span class="n">E</span><span class="p">[</span><span class="o">++</span><span class="n">cnt</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">next</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="n">a</span><span class="p">];</span>
		<span class="n">v</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">E</span><span class="p">[</span><span class="o">++</span><span class="n">cnt</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">next</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
		<span class="n">v</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">dij</span><span class="p">(</span><span class="n">mf</span><span class="p">))</span> <span class="c1">//先判断在最大权值下是否能够到达
</span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"AFK"</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">l</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">r</span><span class="p">(</span><span class="n">mf</span><span class="p">);</span>
		<span class="k">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="p">)</span> <span class="c1">//二分答案
</span>		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">mid</span><span class="p">((</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">dij</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span>	<span class="n">r</span><span class="o">=</span><span class="n">mid</span><span class="p">;</span>
			<span class="k">else</span>	<span class="n">l</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> 最短路 </category>
        
          <category> 分治 </category>
        
      </categories>
      <tags>
        
          <tag> dijkstra </tag>
        
          <tag> 二分答案 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu2709)小B的询问]]></title>
      <url>/solution/%E8%8E%AB%E9%98%9F/2017/11/03/Bque/</url>
      <content type="html"><![CDATA[<p>一道莫队算法练手题
<!-- more --></p>
<h2 id="题目描述">题目描述:</h2>

<p><strong>给出一个包含n(n&lt;=50000)个1~k(k&lt;=50000)之间的数的序列, 有m(m&lt;=50000)个询问, 每次询问给出一个[l,r]的区间, 求区间中c(i)^2的和, 其中c(i)表示数字i在区间[l,r]的重复次数</strong></p>

<h2 id="思路">思路:</h2>

<p><strong>离线莫队算法</strong></p>

<p>根据公式(c+1)^2=c^2+2*c+1可以在O(1)时间内推出[l-1,r]或[l,r+1]</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">50005</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mk</span><span class="p">(</span><span class="mi">50005</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">50005</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">blo</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span> <span class="c1">//blo:分块号
</span><span class="k">struct</span> <span class="n">q</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">id</span><span class="p">;</span> <span class="c1">//区间左端, 右端, 询问时间
</span>	<span class="kt">bool</span> <span class="k">operator</span> <span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">q</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">blo</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">==</span><span class="n">blo</span><span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">l</span><span class="p">]</span> <span class="o">?</span> <span class="n">r</span><span class="o">&lt;</span><span class="n">x</span><span class="p">.</span><span class="n">r</span> <span class="o">:</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">x</span><span class="p">.</span><span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span><span class="n">que</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">k</span><span class="p">[</span><span class="n">Mk</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">ans</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d %*d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">unit</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">));</span> <span class="c1">//单位分块大小
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">i</span><span class="p">),</span> <span class="n">blo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="n">unit</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">que</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">l</span><span class="p">,</span><span class="o">&amp;</span><span class="n">que</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r</span><span class="p">);</span>
		<span class="n">que</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">que</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">que</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">r</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="n">que</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">l</span><span class="o">&lt;</span><span class="n">l</span><span class="p">)</span> <span class="c1">//区间转移
</span>		<span class="p">{</span>
			<span class="n">t</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="o">--</span><span class="n">l</span><span class="p">]]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="o">++</span><span class="n">k</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">]];</span>
		<span class="p">}</span>
		<span class="k">while</span><span class="p">(</span><span class="n">que</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r</span><span class="o">&gt;</span><span class="n">r</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">t</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="o">++</span><span class="n">r</span><span class="p">]]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="o">++</span><span class="n">k</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">]];</span>
		<span class="p">}</span>
		<span class="k">while</span><span class="p">(</span><span class="n">que</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">l</span><span class="o">&gt;</span><span class="n">l</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">t</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="o">--</span><span class="n">k</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">]];</span>
		<span class="p">}</span>
		<span class="k">while</span><span class="p">(</span><span class="n">que</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r</span><span class="o">&lt;</span><span class="n">r</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">t</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="o">--</span><span class="n">k</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="o">--</span><span class="p">]];</span>
		<span class="p">}</span>
		<span class="n">ans</span><span class="p">[</span><span class="n">que</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="c1">//保存答案
</span>	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> 莫队 </category>
        
      </categories>
      <tags>
        
          <tag> 莫队 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1850)换教室(NOIP2016 D1T3)]]></title>
      <url>/solution/dp/%E6%9C%80%E7%9F%AD%E8%B7%AF/2017/11/02/cclass/</url>
      <content type="html"><![CDATA[<p>去年的真题, 经典dp
<!-- more --></p>
<h2 id="题目描述">题目描述:</h2>

<p>略</p>

<h2 id="思路">思路:</h2>

<p><strong>floyd求最短路+概率dp</strong></p>

<p>先用floyd求出每两个点间的最短距离</p>

<p>用d(i,j,0/1)表示在前i个时间段, 换教室j次, 第i次换或不换的最小数学期望</p>

<p>答案为min{d(n,j,0/1)}(0&lt;=j&lt;=m)</p>

<p>转移方程见代码</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">2005</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">2005</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mv</span><span class="p">(</span><span class="mi">305</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">qr</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="c1">//快速读入
</span><span class="p">{</span>
	<span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="kt">char</span> <span class="n">c</span><span class="p">(</span><span class="n">getchar</span><span class="p">());</span>
	<span class="k">while</span><span class="p">(</span><span class="n">c</span><span class="o">&lt;</span><span class="sc">'0'</span> <span class="o">||</span> <span class="n">c</span><span class="o">&gt;</span><span class="sc">'9'</span><span class="p">)</span>	<span class="n">c</span><span class="o">=</span><span class="n">getchar</span><span class="p">();</span>
	<span class="k">while</span><span class="p">(</span><span class="n">c</span><span class="o">&gt;=</span><span class="sc">'0'</span><span class="o">&amp;&amp;</span><span class="n">c</span><span class="o">&lt;=</span><span class="sc">'9'</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="p">(</span><span class="n">c</span><span class="o">-</span><span class="sc">'0'</span><span class="p">);</span>
		<span class="n">c</span><span class="o">=</span><span class="n">getchar</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="n">f</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mm</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dis</span><span class="p">[</span><span class="n">Mv</span><span class="p">][</span><span class="n">Mv</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">p</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">v</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">e</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">qr</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">qr</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%lf"</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span><span class="mh">0x3f</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">dis</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">v</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">e</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
		<span class="n">qr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">qr</span><span class="p">(</span><span class="n">y</span><span class="p">),</span><span class="n">qr</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
		<span class="n">dis</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">],</span><span class="n">z</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*floyd最短路*/</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">v</span><span class="p">;</span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">v</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">v</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
				<span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">dis</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
	<span class="n">m</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">);</span> <span class="c1">//!!!m最多与n相等
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e15</span><span class="p">;</span>
	<span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="c1">//j最多与i相等
</span>		<span class="p">{</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dis</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span> <span class="c1">//这次不换教室, 上一次也没换
</span>			<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>	<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dis</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">+</span> <span class="p">((</span><span class="mf">1.0</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dis</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]]));</span> <span class="c1">//这次不换, 上次换了
</span>			<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>	<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">dis</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">+</span> <span class="p">((</span><span class="mf">1.0</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">dis</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span> <span class="c1">//这次换了, 上次没换
</span>			<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>	<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">dis</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">+</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">dis</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">+</span><span class="p">((</span><span class="mf">1.0</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">dis</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">+</span><span class="p">((</span><span class="mf">1.0</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">dis</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]]));</span> <span class="c1">//这次换了, 上次也换了
</span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kt">double</span> <span class="n">ans</span><span class="p">(</span><span class="mf">1e15</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%.2lf"</span><span class="p">,</span><span class="n">ans</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
          <category> 最短路 </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> floyd </tag>
        
          <tag> 概率dp </tag>
        
          <tag> 数学期望 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1886)滑动窗口]]></title>
      <url>/solution/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2017/11/01/window/</url>
      <content type="html"><![CDATA[<p>一道单调队列的入门题
<!-- more --></p>
<h2 id="题目描述">题目描述:</h2>

<p><strong>给出一个有n(n&lt;=1e6)个数字的序列, 以及一个大小为k(k&lt;=n)的窗口, 这个窗口从最左边开始往右滑动, 每次滑动一个单位, 求这个序列里在这个窗口中的数的最大和最小值</strong></p>

<h2 id="思路">思路:</h2>

<p><strong>单调队列的入门题</strong></p>

<p>维护两个单调队列, 一个递增, 一个递减, 分别表示最大值和最小值, 移动窗口前时判断队首是否等于当前最左端值, 如果相等则队首出队</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">1000005</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">sq</span>
<span class="p">{</span>
	<span class="k">private</span><span class="o">:</span>
		<span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">MS</span><span class="o">=</span><span class="mi">1000005</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">q</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
		<span class="kt">bool</span> <span class="n">isu</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">h</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">;</span> <span class="c1">//队首, 队尾及队的大小
</span>	<span class="nl">public:</span>
		<span class="n">sq</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span><span class="o">:</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">s</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">isu</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">//false表递减, true表递增
</span>		<span class="kt">bool</span> <span class="n">emp</span><span class="p">()</span>
		<span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">s</span><span class="p">;</span> <span class="p">}</span>
		<span class="kt">int</span> <span class="n">fr</span><span class="p">()</span>
		<span class="p">{</span> <span class="k">return</span> <span class="n">q</span><span class="p">[</span><span class="n">h</span><span class="p">];</span> <span class="p">}</span>
		<span class="kt">void</span> <span class="n">pop</span><span class="p">()</span>
		<span class="p">{</span> <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">h</span><span class="o">=</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MS</span><span class="p">,</span><span class="o">--</span><span class="n">s</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//单调队列出队操作
</span>		<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">isu</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">while</span><span class="p">(</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">[(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">MS</span><span class="p">)</span><span class="o">%</span><span class="n">MS</span><span class="p">]</span><span class="o">&lt;</span><span class="n">x</span><span class="p">)</span> <span class="c1">//当队尾小于当前插入值时, 队尾出队
</span>				<span class="p">{</span>
					<span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">MS</span><span class="p">)</span><span class="o">%</span><span class="n">MS</span><span class="p">;</span>
					<span class="o">--</span><span class="n">s</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">q</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MS</span><span class="p">,</span> <span class="o">++</span><span class="n">s</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="k">while</span><span class="p">(</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">[(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">MS</span><span class="p">)</span><span class="o">%</span><span class="n">MS</span><span class="p">]</span><span class="o">&gt;</span><span class="n">x</span><span class="p">)</span> <span class="c1">//递减相反
</span>				<span class="p">{</span>
					<span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">MS</span><span class="p">)</span><span class="o">%</span><span class="n">MS</span><span class="p">;</span>
					<span class="o">--</span><span class="n">s</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">q</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MS</span><span class="p">,</span> <span class="o">++</span><span class="n">s</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
	<span class="n">sq</span> <span class="n">mn</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="n">mx</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">mn</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="n">mx</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mn</span><span class="p">.</span><span class="n">fr</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">mn</span><span class="p">.</span><span class="n">fr</span><span class="p">())</span>	<span class="n">mn</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">//判定队首是否在窗口中
</span>		<span class="n">mn</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">//窗口右端入队
</span>		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">mn</span><span class="p">.</span><span class="n">fr</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">mx</span><span class="p">.</span><span class="n">fr</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">//同上
</span>	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">mx</span><span class="p">.</span><span class="n">fr</span><span class="p">())</span>	<span class="n">mx</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="n">mx</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">mx</span><span class="p">.</span><span class="n">fr</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> 数据结构 </category>
        
      </categories>
      <tags>
        
          <tag> 数据结构 </tag>
        
          <tag> 单调队列 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(UVa1025)地铁里的间谍(A Spy in the Metro)]]></title>
      <url>/solution/dp/2017/10/31/spy/</url>
      <content type="html"><![CDATA[<p>一道经典题
<!-- more --></p>
<h2 id="题目描述">题目描述:</h2>

<p><strong>某城市的地铁只有一条线路, 有n个车站(n&lt;=50), 有M1辆列车从1号站往右开, M2辆列车从n号站往左开</strong></p>

<p><strong>间谍Mario从1号站出发, 要在时刻T(T&lt;=200)会见在n站的一个间谍, 给出地铁的发车时刻和相邻两个站之间的行驶时间, 求Mario在车站上的最少等待时间(无解输出”impossible”)</strong></p>

<h2 id="思路">思路:</h2>

<p><strong>以时间为序的多阶段dp</strong></p>

<p>设d(i,j)是间谍Mario在车站i, 时刻j的最小等待时间</p>

<p>则答案为d(n,T), 初始化d(0,0)=0, 其它d为无穷大, 若d(n,T)等于无穷大无解</p>

<p>状态转移方程见代码:</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">55</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mt</span><span class="p">(</span><span class="mi">205</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mt</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dis</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span> <span class="c1">//相邻两车站间距离
</span><span class="kt">bool</span> <span class="n">ist</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mt</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">//车站i,时刻j是否有车(0:右驶,1:左驶)
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">cs</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">T</span><span class="p">;</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">dis</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ist</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">ist</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m1</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m1</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
			<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
			<span class="n">ist</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
				<span class="n">ist</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">t</span><span class="o">+=</span><span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m2</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m2</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
			<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
			<span class="n">ist</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span><span class="o">--</span><span class="n">j</span><span class="p">)</span>
				<span class="n">ist</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">t</span><span class="o">+=</span><span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mh">0x3f</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">d</span><span class="p">);</span>
		<span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">T</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>	<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]);</span> <span class="c1">//如果有向右驶的车
</span>				<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">ist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span> <span class="c1">//如果有向左驶的车
</span>				<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//等待
</span>			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Case Number %d: "</span><span class="p">,</span><span class="o">++</span><span class="n">cs</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">T</span><span class="p">]</span><span class="o">==</span><span class="mh">0x3f3f3f3f</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"impossible</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">else</span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">T</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu2014)选课]]></title>
      <url>/solution/dp/2017/10/31/class/</url>
      <content type="html"><![CDATA[<p>一道经典树状dp
<!-- more --></p>
<h2 id="题目描述">题目描述:</h2>

<p><strong>在大学里的每个学生, 为了达到一定的学分, 必须从很多课程里选择一些课程来学习, 有些课程必须在某些课程之前学习</strong></p>

<p><strong>现给出n(n&lt;=300)个课程的先修课和学分, 在这n门课中选择m(m&lt;=300)门学习, 求能获得的最大学分</strong></p>

<h2 id="思路">思路:</h2>

<p><strong>树状dp</strong></p>

<p>某一课程的先修课和这门课之间在树上构成了一种父子关系, 可以将这些课组织成一棵树, 并将这颗多叉树转为二叉树(即记录这个结点的子结点以及下一个兄弟结点), 并构造一个虚拟结点0用来表示根结点</p>

<p>设d(i,j)为以i为根的子树, 选择j门课的最优解</p>

<p>则答案为d(son(0),m)</p>

<p>对于每个结点,枚举分配到兄弟和子结点的课程数</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">305</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">305</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span> <span class="c1">//学分
</span><span class="kt">int</span> <span class="n">son</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">bro</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span> <span class="c1">//一个点的子结点以及兄弟结点
</span><span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mm</span><span class="p">];</span> <span class="c1">//以i为根, 可选j门课的最优解
</span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">rt</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">rt</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span>	<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">rt</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
	<span class="k">if</span><span class="p">(</span><span class="n">rt</span><span class="o">==</span><span class="mi">0</span><span class="o">||</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>	<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">rt</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//边界,当i为空或无课程可供分配时答案为0
</span>	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">d</span><span class="p">[</span><span class="n">rt</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">bro</span><span class="p">[</span><span class="n">rt</span><span class="p">],</span><span class="n">k</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">d</span><span class="p">[</span><span class="n">rt</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">rt</span><span class="p">][</span><span class="n">k</span><span class="p">],</span><span class="n">f</span><span class="p">(</span><span class="n">son</span><span class="p">[</span><span class="n">rt</span><span class="p">],</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">bro</span><span class="p">[</span><span class="n">rt</span><span class="p">],</span><span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">s</span><span class="p">[</span><span class="n">rt</span><span class="p">]);</span> <span class="c1">//枚举分配到兄弟和子结点的课程数
</span>		<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">rt</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
		<span class="n">bro</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">son</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="n">son</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">d</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="n">son</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">m</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> 树上dp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(UVa116)单向TSP(Unidirectional TSP)]]></title>
      <url>/solution/dp/2017/10/30/UVa116/</url>
      <content type="html"><![CDATA[<p>打印路径的dp思路
<!-- more --></p>
<h2 id="题目描述">题目描述:</h2>

<p><strong>给出一个m*n(m&lt;=10,n&lt;=100)的矩阵, 从第一列的某一位置出发, 每次向右,右上或右下走一格, 最终到达最后一列, 整个矩阵是环形的, 要求经过的整数和最小, 输出最优解及路径所经过的行号</strong></p>

<h2 id="思路">思路:</h2>

<p><strong>多段图dp</strong></p>

<p>因为要求路径, 所以设d(i,j)为以(i,j)为起点的最短路径和, 用nxt(i,j)表示路径上下一列的行号</p>

<p>则答案为min{d(k,1)}(1&lt;=k&lt;=n)</p>

<p>状态转移方程见代码</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">105</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nxt</span><span class="p">[</span><span class="n">Mm</span><span class="p">][</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">mp</span><span class="p">[</span><span class="n">Mm</span><span class="p">][</span><span class="n">Mn</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">Mm</span><span class="p">][</span><span class="n">Mn</span><span class="p">];</span> <span class="c1">//mp表示(i,j)上的值
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//多组数据输入
</span>	<span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">mp</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
				<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mh">0x3f</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">d</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">nxt</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">nxt</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">];</span> <span class="c1">//初始化d(i,n)
</span>		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="kt">int</span> <span class="n">nr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">};</span>
				<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="n">nr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">m</span><span class="p">)</span> <span class="n">nr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">sort</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">nr</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span> <span class="c1">//按字典序选择决策
</span>				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">k</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">nr</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">mp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
					<span class="p">{</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">nr</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">mp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">];</span> <span class="n">nxt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nr</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="p">}</span> <span class="c1">//更新当前最优解
</span>				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="kt">int</span> <span class="n">ans</span><span class="p">(</span><span class="n">INT_MAX</span><span class="p">),</span> <span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">//搜索最优解
</span>			<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">ans</span><span class="p">)</span>
			<span class="p">{</span> <span class="n">ans</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="n">p</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="p">}</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">//打印路径
</span>		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="mi">1</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> 字典序 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(vijos1037)搭建双塔]]></title>
      <url>/solution/dp/2017/10/28/ditower/</url>
      <content type="html"><![CDATA[<p>一道经典神题
<!-- more --></p>
<h2 id="题目描述">题目描述:</h2>

<p><strong>给出n(1&lt;=n&lt;=100)个水晶的高度, 用这些水晶搭建两座高度相同的塔, 求塔的最大高度(无解输出”Impossible”)</strong></p>

<h2 id="思路">思路:</h2>

<p><strong>动规</strong></p>

<p>用d(i,j)表示用前i个水晶, 两塔高度差为j时两塔中高塔的最大高度</p>

<p>转移方程见代码</p>

<p>答案为d(n,0)</p>

<p>当d(n,0)==0时输出Impossible</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">105</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">2005</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mm</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//最大高度差 
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">i</span><span class="p">),</span><span class="n">sum</span><span class="o">+=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mh">0xc0</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">d</span><span class="p">);</span> <span class="c1">//初始化为极小值 
</span>	<span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">sum</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span> <span class="c1">//不使用水晶 
</span>			<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span> <span class="c1">//使用水晶搭在矮塔上, 矮塔还是矮塔 
</span>			<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">//使用水晶搭在高塔上 
</span>			<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">j</span><span class="p">);</span> <span class="c1">//使用水晶搭在矮塔上, 矮塔变高塔 
</span>		<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Impossible"</span><span class="p">;</span> <span class="c1">//当最终建成高度为0时, 塔不存在 
</span>	<span class="k">else</span>			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1043)数字游戏]]></title>
      <url>/solution/dp/2017/10/27/numgame/</url>
      <content type="html"><![CDATA[<p>一个新的dp模版
<!-- more --></p>

<h2 id="题目描述">【题目描述】</h2>

<p><strong>将一圈整数分为m个部分, 使得每个部分的和对10取模后乘积最大</strong></p>

<h2 id="思路">思路:</h2>

<p><strong>化环为链+区间dp</strong></p>

<p>设d(l,r,k)是将区间[l,r]分为k段的最优解</p>

<p>那么就有d(l,r,k)=d(l,c,s)*d(c+1,r,k-s)(l&lt;=c&lt;r, 1&lt;=s&lt;k)</p>

<p>答案为max/min{d(i,i+n-1,m)}(1&lt;=i&lt;=n)</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;climits&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">115</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">dmn</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mm</span><span class="p">],</span><span class="n">dmx</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mm</span><span class="p">];</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fmn</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="c1">//最大值
</span><span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">dmn</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">)</span>	<span class="k">return</span> <span class="n">dmn</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
		    <span class="kt">int</span> <span class="n">ans</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="mi">10</span><span class="p">);</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">ans</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>  <span class="n">ans</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
		    <span class="k">return</span> <span class="n">dmn</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="n">ans</span><span class="p">(</span><span class="n">INT_MAX</span><span class="p">);</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">(</span><span class="n">l</span><span class="p">);</span><span class="n">c</span><span class="o">&lt;</span><span class="n">r</span><span class="p">;</span><span class="o">++</span><span class="n">c</span><span class="p">)</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">ks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">ks</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span><span class="o">++</span><span class="n">ks</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="n">ks</span><span class="o">&lt;=</span><span class="n">c</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="o">-</span><span class="n">ks</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">-</span><span class="n">c</span><span class="p">)</span>
					<span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="n">fmn</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">ks</span><span class="p">)</span><span class="o">*</span><span class="n">fmn</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">ks</span><span class="p">));</span>
				<span class="p">}</span>
			<span class="k">return</span> <span class="n">dmn</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">ans</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fmx</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="c1">//最小值
</span><span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">dmx</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">)</span>	<span class="k">return</span> <span class="n">dmx</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
		    <span class="kt">int</span> <span class="n">ans</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">%</span><span class="mi">10</span><span class="p">);</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">ans</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>  <span class="n">ans</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
		    <span class="k">return</span> <span class="n">dmx</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="n">ans</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">(</span><span class="n">l</span><span class="p">);</span><span class="n">c</span><span class="o">&lt;</span><span class="n">r</span><span class="p">;</span><span class="o">++</span><span class="n">c</span><span class="p">)</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">ks</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">ks</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span><span class="o">++</span><span class="n">ks</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="n">ks</span><span class="o">&lt;=</span><span class="n">c</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="o">-</span><span class="n">ks</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">-</span><span class="n">c</span><span class="p">)</span>
					<span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span><span class="n">fmx</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">ks</span><span class="p">)</span><span class="o">*</span><span class="n">fmx</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">ks</span><span class="p">));</span>
				<span class="p">}</span>
			<span class="k">return</span> <span class="n">dmx</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">s</span><span class="o">+</span><span class="n">i</span><span class="p">),</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dmn</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">dmn</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dmx</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">dmx</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>	<span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="c1">//前缀和优化区间和
</span>	<span class="kt">long</span> <span class="kt">long</span> <span class="n">Min</span><span class="p">(</span><span class="n">INT_MAX</span><span class="p">),</span><span class="n">Max</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//寻找最优解
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Min</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">Min</span><span class="p">,</span><span class="n">fmn</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">));</span>
		<span class="n">Max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Max</span><span class="p">,</span><span class="n">fmx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Min</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> 区间dp </tag>
        
          <tag> 环状区间 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu2701)巨大的牛棚(USACO5.3)]]></title>
      <url>/solution/dp/2017/10/27/maxsq/</url>
      <content type="html"><![CDATA[<p>最大正方形</p>

<p>又一个dp的模板
<!-- more --></p>
<h2 id="题目描述">题目描述:</h2>

<p><strong>在n*n(n&lt;=1000)的矩阵中, 有几个点不能选, 找出当中边长最大的正方形</strong></p>

<h2 id="思路">思路:</h2>

<p>设d(i,j)是以点(i,j)为右下角的最大正方形边长</p>

<p>则有d(i,j) = min{d(i-1,j),d(i,j-1),d(i-1,j-1))+1</p>

<p>即只有当上面, 左边, 左上角都能构成边长为k的正方形时, 点(i,j)才能形成边长为k+1的正方形</p>

<p><img src="/assets/images/table.png" alt="" /></p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nclude</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span>
<span class="cp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">1005</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">mp</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">mp</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">mp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//处理边界
</span>	<span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
		<span class="n">mp</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">Max</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="k">if</span><span class="p">(</span><span class="n">mp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>	
			<span class="p">{</span>
				<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">Max</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Max</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
			<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Max</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu3004)宝箱(USACO10DEC)]]></title>
      <url>/solution/dp/2017/10/27/U10DEC/</url>
      <content type="html"><![CDATA[<p>一道dp的博弈题
<!-- more --></p>

<h2 id="题目描述">【题目描述】</h2>

<p><strong>n个硬币排成一行, 每个硬币有一个价值Ci, 两个人轮流取硬币</strong></p>

<p><strong>规定每个人每次只能拿走剩余硬币中最左边或最右边的硬币, 若硬币全部取完, 游戏结束</strong></p>

<p><strong>求当两边都完美操作时先手能取得的硬币总和的最大值</strong></p>

<h2 id="思路">思路:</h2>

<p><strong>区间dp</strong></p>

<p>设d(l,r)为在区间[l,r]上的最优解, 则对手的最优解为d(l+1,r)和d(l,r-1)的最大值</p>

<p>那么就有<strong>d(l,r) = max(sum(l,r)-d(l+1,r),sum(l,r)-d(l,r-1))</strong></p>

<p>即在对手剩下的局面中选择最优解</p>

<p>由于要求先手的最优解, 所以答案为d(1,n)</p>

<h2 id="代码实现">代码实现:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">5005</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span> <span class="c1">//前缀和优化区间和
</span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="c1">//记忆化搜索
</span><span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">])</span>	<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">];</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="p">)</span>	<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">f</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> 区间dp </tag>
        
          <tag> 博弈 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu3916)图的遍历]]></title>
      <url>/solution/%E5%9B%BE%E8%AE%BA/scc/dp/2017/10/26/gra_erg/</url>
      <content type="html"><![CDATA[<p>有的题看似简单实则不易
<!-- more --></p>

<h2 id="题目描述">【题目描述】</h2>

<p><strong>给出n个点, m条边的有向图, 对于每个点v, 求从v出发能到达的编号最大的点</strong></p>

<h2 id="输入输出">【输入输出】</h2>

<h3 id="输入格式">输入格式：</h3>

<p><strong>第一行为两个整数n,m</strong></p>

<p><strong>接下来m行, 每行2个整数u,v, 表示u到v有条有向边, 点用1到n的数字编号</strong></p>

<h3 id="输出格式">输出格式:</h3>

<p><strong>n个整数, 表示从i能到达的最大编号的结点</strong></p>

<h2 id="思路">思路:</h2>

<p>一开始想用dp解决, 但WA了6个点</p>

<p>后来发现这张图不一定是DAG, 无法直接使用dp</p>

<p>于是就只能先用tarjan把图缩成DAG, 再用dp解决</p>

<p>(貌似题解中说可以反向bfs, 没试过所以没有代码)</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">100005</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">100005</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">edge</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">edge</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">E</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span> <span class="c1">//边表
</span><span class="n">edge</span> <span class="o">*</span><span class="n">vd</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">Ed</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">scn</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pre</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">low</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">scc</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">S</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">tar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pre</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">t</span><span class="p">;</span>
	<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">S</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">e</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">tar</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">);</span>
			<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">low</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">scc</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">])</span>
			<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">pre</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="o">++</span><span class="n">scn</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">u</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="p">());</span> <span class="n">S</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">scc</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">scn</span><span class="p">;</span>
			<span class="n">f</span><span class="p">[</span><span class="n">scn</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">scn</span><span class="p">],</span><span class="n">u</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">u</span><span class="p">)</span>	<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">sin</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">topo</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">mdfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="c1">//记忆化搜索
</span><span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>    <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">e</span><span class="p">(</span><span class="n">vd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">mdfs</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span> <span class="c1">//读入图
</span>		<span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
		<span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">E</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">tar</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//tarjan找scc
</span>	<span class="cm">/*----缩点----*/</span>
	<span class="kt">int</span> <span class="n">ecn</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">e</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">if</span><span class="p">(</span><span class="n">scc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">scc</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="o">++</span><span class="n">sin</span><span class="p">[</span><span class="n">scc</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]];</span>
				<span class="n">Ed</span><span class="p">[</span><span class="o">++</span><span class="n">ecn</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">scc</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">],</span> <span class="n">Ed</span><span class="p">[</span><span class="n">ecn</span><span class="p">].</span><span class="n">next</span><span class="o">=</span><span class="n">vd</span><span class="p">[</span><span class="n">scc</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
				<span class="n">vd</span><span class="p">[</span><span class="n">scc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Ed</span><span class="o">+</span><span class="n">ecn</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="cm">/*--------*/</span>
	<span class="cm">/*----拓扑排序并dp----*/</span>
	<span class="kt">int</span> <span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">scn</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">h</span><span class="o">!=</span><span class="n">t</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">e</span><span class="p">(</span><span class="n">vd</span><span class="p">[</span><span class="n">topo</span><span class="p">[</span><span class="n">h</span><span class="p">]]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="o">--</span><span class="n">sin</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sin</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">])</span>	<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">h</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
		<span class="n">mdfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//按照拓扑逆序dp
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">scc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>(所以说有些题目还是没有想象中的那么简单啊…)</p>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> 图论 </category>
        
          <category> scc </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> 图论 </tag>
        
          <tag> dp </tag>
        
          <tag> tarjan </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[拓扑排序及应用]]></title>
      <url>/note/%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/2017/10/25/topo-sort/</url>
      <content type="html"><![CDATA[<!-- more -->
<h2 id="什么是拓扑排序">什么是拓扑排序:</h2>

<p>对于一个有向图G, 如果存在一种结点的序列, 使得对于每条边(u, v), 都有u在v的前面, 则这个顺序叫做拓扑序, 给图排拓扑序的过程即是拓扑排序</p>

<p><strong>显然, 只有DAG才存在拓扑序。</strong></p>

<h2 id="如何进行拓扑排序">如何进行拓扑排序:</h2>

<p>有两种方法:</p>

<p><strong>1.dfs:</strong></p>

<p>dfs遍历DAG, 并在遍历完后将结点放在当前序列的首部</p>

<p><strong>—-代码—-(来自紫书)</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">topo</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span> <span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">dfs</span>
<span class="p">{</span>
	<span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">//访问标志
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">v</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//存在有向环, 排序失败
</span>			<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">topo</span><span class="p">[</span><span class="o">--</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">u</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>2.bfs:</strong></p>

<p>运用一个队列, 删除在队头的结点， 并寻找入度为0的点入队</p>

<p><strong>—-代码—-</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">topo</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">in</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span> <span class="c1">//入度
</span><span class="kt">int</span> <span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">h</span><span class="o">!=</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">e</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">topo</span><span class="p">[</span><span class="n">h</span><span class="p">]]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="o">--</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">])</span>
			<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">++</span><span class="n">h</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="拓扑排序的作用">拓扑排序的作用:</h2>

<p>首先, 拓扑序可以用来定任务的起始时间, 这也是一般书上讲的东西</p>

<p>其次, 拓扑序<strong>可以判定一个有向图是不是DAG</strong></p>

<p>因为<strong>有且只有DAG才存在拓扑序</strong></p>

<p>那么, 如果将DAG的性质和定序结合起来会怎么样?</p>

<p>我们知道, <strong>DAG与dp有密不可分的关系</strong></p>

<p>而拓扑序可以给出DAG的处理顺序…</p>

<p>也就是说, <strong>拓扑序可以给出DAG上dp的计算顺序</strong></p>

<p>这也是一般DAG上dp的优化思路</p>
]]></content>
      <categories>
        
          <category> note </category>
        
          <category> 图论 </category>
        
          <category> 拓扑排序 </category>
        
      </categories>
      <tags>
        
          <tag> 图论 </tag>
        
          <tag> 拓扑排序 </tag>
        
          <tag> DAG </tag>
        
          <tag> dp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[tarjan求scc及其应用]]></title>
      <url>/note/%E5%9B%BE%E8%AE%BA/tarjan/2017/10/25/tarjan/</url>
      <content type="html"><![CDATA[<!-- more -->
<h2 id="什么是scc强连通分量">什么是scc(强连通分量):</h2>

<p>在有向图中, 如果若干个点相互可达, 则这几个点构成的集合称为有向图的一个强连通分量</p>

<p>如果把这个图中所有的极大强连通分量变为一个点, 这个图叫scc图。这个图中不存在有向环, 所以scc图是一个DAG</p>

<h2 id="如何求有向图的scc">如何求有向图的scc:</h2>

<p>一般使用tarjan算法</p>

<p>tarjan借助<strong>dfs</strong>, 在dfs时记录访问的结点v的<strong>时间戳</strong>(pre), 并设<strong>v及其后代在dfs树上能追溯到的最早的祖先结点</strong>为low, 当回溯时如果pre==low, 则说明找到一个scc。</p>

<p>用一个栈辅助存储dfs中子树的结点, 当找到scc时将栈中的结点弹出, 弹出的结点即是scc中的结点。</p>

<p><strong>—-代码—-</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//时间戳
</span><span class="kt">int</span> <span class="n">pre</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span> <span class="n">scc</span><span class="p">[</span><span class="n">Mn</span><span class="p">]</span> <span class="c1">//pre,low,结点的scc编号
</span><span class="kt">int</span> <span class="n">scn</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//scc计数器
</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">S</span><span class="p">;</span> <span class="c1">//辅助存储
</span><span class="kt">void</span> <span class="nf">tarjan</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pre</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">t</span><span class="p">;</span>
	<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">S</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>	<span class="c1">//遍历有向边
</span>	<span class="p">{</span>
		<span class="kt">int</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pre</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="c1">//如果未访问, 即访问到的是子结点
</span>		<span class="p">{</span>
			<span class="n">tarjan</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">//dfs
</span>			<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">scc</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="c1">//如果访问到的是祖先节点
</span>			<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">pre</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="o">++</span><span class="n">scn</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">u</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">top</span><span class="p">());</span> <span class="n">S</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">scc</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">scn</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">==</span><span class="n">x</span><span class="p">)</span>	<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="tarjan算法的作用">tarjan算法的作用:</h2>

<p>首先, scc是由一个或多个环组成的, 可以用tarjan来寻找有向图中的环</p>

<p>最主要的是, 将有向图缩点形成的scc图是一个DAG, 对于有向非DAG的最优解, 可以先用tarjan将图缩成DAG, 然后使用dp解决</p>
]]></content>
      <categories>
        
          <category> note </category>
        
          <category> 图论 </category>
        
          <category> tarjan </category>
        
      </categories>
      <tags>
        
          <tag> 图论 </tag>
        
          <tag> 缩点 </tag>
        
          <tag> tarjan </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈dp与DAG的关系]]></title>
      <url>/note/dp/%E5%9B%BE%E8%AE%BA/2017/10/25/DAGviaDP/</url>
      <content type="html"><![CDATA[<!-- more -->
<p>最近做了好几道跟DAG有关的题, 发现许多都和dp有关, 经过一番思考, 想到一些东西, 在这里记录下来。</p>

<p>首先是dp的定义: <strong>通过定义状态和状态间的关系, 拆分子问题去求解最优解。</strong></p>

<p>拆分子问题实质上是一个递归的过程, 类似于分治</p>

<p>如果把状态和状态间的转移关系看成一张有向图G的话, 那么拆分问题的过程 <strong>实质上是在G上进行dfs</strong></p>

<p>如果G不是DAG的话, 那么G中就会有一个环(就像下面这个图)</p>

<p><img src="/assets/images/pic_cir_gra.png" alt="Circle" /></p>

<p>在G中进行dfs时, 假如从1开始dfs, 那么遍历到3时,  3的最优解要由1决定, 而1的最优解还未求得, 导致答案错误。</p>

<p>所以根据状态和状态转移关系定义的图一定要是一个DAG, 否则无法通过dp求解</p>
]]></content>
      <categories>
        
          <category> note </category>
        
          <category> dp </category>
        
          <category> 图论 </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> DAG </tag>
        
          <tag> 图论 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1137) 旅行计划]]></title>
      <url>/solution/dp/%E5%9B%BE%E8%AE%BA/2017/10/24/trip_plan/</url>
      <content type="html"><![CDATA[<!-- more -->
<h2 id="题目描述">题目描述：</h2>

<p><strong>小明要去一个国家旅游。这个国家有N个城市，编号为1～N，并且有M条道路连接着，小明准备从其中一个城市出发，并只往东走到城市i停止。</strong></p>

<p><strong>所以他就需要选择最先到达的城市，并制定一条路线以城市i为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。</strong></p>

<p><strong>现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的i，都需要你为小明制定一条路线，并求出以城市i为终点最多能够游览多少个城市。</strong></p>

<h2 id="输入输出">输入输出：</h2>

<h3 id="输入">输入：</h3>

<p><strong>输入的第1行为两个正整数N, M。</strong></p>

<p><strong>接下来M行，每行两个正整数x, y，表示了有一条连接城市x与城市y的道路，保证了城市x在城市y西面。</strong></p>

<h3 id="输出">输出：</h3>

<p><strong>输出包括N行，第i行包含一个正整数，表示以第i个城市为终点最多能游览多少个城市。</strong></p>

<h2 id="题解">题解：</h2>

<p>由于只往东走，所以这是一个 <strong>DAG</strong></p>

<p>DAG上的最长路用dp解决</p>

<p>求拓扑序时dp求解最长路</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">100005</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mm</span><span class="p">(</span><span class="mi">200005</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">edge</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">e</span><span class="p">;</span>
	<span class="n">edge</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="o">*</span><span class="n">vr</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">Er</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span>	<span class="c1">//反向边
</span><span class="n">edge</span> <span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">E</span><span class="p">[</span><span class="n">Mm</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">ans</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">topo</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>	<span class="c1">//拓扑序
</span><span class="kt">int</span> <span class="n">in</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>	<span class="c1">//入度
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
		<span class="o">++</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="p">];</span>
		<span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
		<span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">E</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
		<span class="n">Er</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">e</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">Er</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="o">=</span><span class="n">vr</span><span class="p">[</span><span class="n">e</span><span class="p">];</span>
		<span class="n">vr</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">Er</span><span class="o">+</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*求拓扑序*/</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>	<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">h</span><span class="o">!=</span><span class="n">t</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">e</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">topo</span><span class="p">[</span><span class="n">h</span><span class="p">]]);</span><span class="n">e</span><span class="p">;</span><span class="n">e</span><span class="o">=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="o">--</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">in</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">])</span>
			<span class="p">{</span>
				<span class="n">topo</span><span class="p">[</span><span class="n">t</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">;</span>
				<span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="o">*</span> <span class="n">er</span><span class="p">(</span><span class="n">vr</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]);</span><span class="n">er</span><span class="p">;</span><span class="n">er</span><span class="o">=</span><span class="n">er</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
					<span class="n">ans</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">],</span><span class="n">ans</span><span class="p">[</span><span class="n">er</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>	<span class="c1">//状态转移方程
</span>			<span class="p">}</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">h</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*--------*/</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
          <category> 图论 </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
          <tag> 图论 </tag>
        
          <tag> DAG </tag>
        
          <tag> 拓扑排序 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1908)逆序对]]></title>
      <url>/solution/%E5%88%86%E6%B2%BB/2017/10/24/rev/</url>
      <content type="html"><![CDATA[<p>一道经典题
<!-- more --></p>

<h2 id="思路">思路:</h2>

<p><strong>使用归并排序的思想解决</strong></p>

<p>将序列从小到大归并排序</p>

<p>当右边的值小于左边的值时加上左边未归并的长度</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">40005</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">Mn</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">Mn</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">mg</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">m</span><span class="p">((</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">mg</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">);</span> <span class="n">ret</span> <span class="o">+=</span> <span class="n">mg</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">li</span><span class="p">(</span><span class="n">l</span><span class="p">),</span><span class="n">ri</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">j</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="k">while</span><span class="p">(</span><span class="n">li</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">&amp;&amp;</span><span class="n">ri</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">li</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">a</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span>	<span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">li</span><span class="o">++</span><span class="p">];</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ri</span><span class="o">++</span><span class="p">];</span>
				<span class="n">ret</span> <span class="o">+=</span> <span class="n">m</span><span class="o">-</span><span class="n">li</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span><span class="p">(;</span><span class="n">li</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">;</span><span class="o">++</span><span class="n">li</span><span class="p">)</span>	<span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">li</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(;</span><span class="n">ri</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="o">++</span><span class="n">ri</span><span class="p">)</span>	<span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ri</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="n">l</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> 分治 </category>
        
      </categories>
      <tags>
        
          <tag> 分治 </tag>
        
          <tag> 归并排序 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1010)幂次方]]></title>
      <url>/solution/%E5%88%86%E6%B2%BB/%E9%80%92%E5%BD%92/2017/10/24/pow/</url>
      <content type="html"><![CDATA[<!-- more -->

<p>将一个数拆分成二进制, 对次数递归表示, 特殊处理0和2的情况</p>

<h2 id="代码">代码:</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">pow2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>    <span class="c1">//特殊处理0
</span>	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">)</span>    <span class="c1">//二进制拆分
</span>			<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">//特殊处理2
</span>				<span class="k">else</span>
				<span class="p">{</span>
					<span class="n">printf</span><span class="p">(</span><span class="s">"2("</span><span class="p">);</span>
					<span class="n">pow2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
					<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">')'</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">n</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'+'</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">pow2</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> 分治 </category>
        
          <category> 递归 </category>
        
      </categories>
      <tags>
        
          <tag> 分治 </tag>
        
          <tag> 二进制 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[(luogu1216)数字三角形(USACO1.5)]]></title>
      <url>/solution/dp/2017/10/24/numtri/</url>
      <content type="html"><![CDATA[<p><strong>Blog第一篇</strong></p>

<p>一道经典题。</p>

<!-- more -->

<p>两个方法:</p>
<h2 id="自底向上推出最优解">自底向上推出最优解:</h2>

<p>用dp[i][j]表示从(i,j)开始的最优解, 答案即为dp[1][1]</p>

<p>状态转移方程: <strong>dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + map[i][j]</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">MR</span><span class="p">(</span><span class="mi">1001</span><span class="p">);</span>    <span class="c1">//n(即题目中的r)的最大值
</span><span class="kt">int</span> <span class="n">map</span><span class="p">[</span><span class="n">MR</span><span class="p">][</span><span class="n">MR</span><span class="p">];</span>    <span class="c1">//保存输入数据
</span><span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">MR</span><span class="p">][</span><span class="n">MR</span><span class="p">];</span>    <span class="c1">//最优解
</span><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dmax</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>    <span class="c1">//返回最大值
</span><span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">//输入n
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>    <span class="c1">//输入数据
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>    <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>   <span class="c1">//初始化，最后一行数据的最优值即为其本身
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dmax</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>    <span class="c1">//向上递推求出最优解
</span>        <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>    <span class="c1">//输出最优解
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="自顶而下推出最优解">自顶而下推出最优解:</h2>
<p>用dp[i][j]表示以(i,j)结束的最优解, 则最优解为最后一行中dp的最大值</p>

<p>状态转移方程: <strong>dp[i][j] = max(dp[i-1][j-1],dp[i-1][j]) + map[i][j]</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">Mn</span><span class="p">(</span><span class="mi">1002</span><span class="p">);</span>    <span class="c1">//n的最大值(定义成1002是为了便于处理边界)
</span><span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">Mn</span><span class="p">][</span><span class="n">Mn</span><span class="p">];</span>    <span class="c1">//最优解
</span><span class="cm">/*边读边求所以省去了map数组*/</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">//输入n
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tn</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tn</span><span class="p">;</span>    <span class="c1">//输入数据
</span>            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">tn</span><span class="p">;</span>    <span class="c1">//求解最优解
</span>        <span class="p">}</span>
    <span class="kt">int</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="n">max</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>    <span class="c1">//寻找最优解
</span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">;</span>    <span class="c1">//输出最优解
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> solution </category>
        
          <category> dp </category>
        
      </categories>
      <tags>
        
          <tag> dp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
